package wctest.translator;

import java.util.ArrayList;

/**
 * Handles generation of an Abstract Syntax Tree (nested nodes of TokenTree) from
 * a list of tokens generated by the Lexer.
 * <br>
 * Follows grammar defined in the <b>WC Test Grammar</b>.
 * <br>
 * Created on: Jul 15, 2015 at 8:09:09 PM
 * @author Matthew Edwards
 */
public class Parser
{
    private static ArrayList<Token> tokens;
    private static Token lookAhead;
    
    /**
     * Parses a list of tokens
     * @param file
     * @return Returns a parsed TokenTree
     */
    public static TokenTree parse(ArrayList<Token> file)
    {
        tokens = file;
        lookAhead = tokens.get(0);
        
        if (lookAhead.getType() == TokenType.WHITESPACE)
        {
            nextToken();
        }
        
        TokenTree root = file();
        
        if (lookAhead.getType() != TokenType.EOF)
        {
            error();
        }
        
        return root;
    }
    
    private static TokenTree error()
    {
        throw new InvalidSyntaxException(lookAhead);
    }
    
    private static void nextToken()
    {
        tokens.remove(0);
        lookAhead = tokens.get(0);
        
        if (lookAhead.getType() == TokenType.WHITESPACE)
        {
            nextToken();
        }
    }
    
    private static boolean accept(TokenType type)
    {
        if (lookAhead.getType() == type)
        {
            nextToken();
            return true;
        }
        return false;
    }
    
    private static void expect(TokenType type)
    {
        if (!accept(type))
        {
            error();
        }
    }
    
    private static TokenTree file()
    {
        if (lookAhead.getType() == TokenType.TEST)
        {
            TokenTree file = new TokenTree(lookAhead);
            nextToken();
            
            if (lookAhead.getType() == TokenType.STRING)
            {
                TokenTree name = new TokenTree(lookAhead);
                nextToken();
                file.addChild(name);
            }
            
            expect(TokenType.LBRACE);
            TokenTree main = new TokenTree(null);
            file.addChild(main);
            
            while (lookAhead.getType() != TokenType.RBRACE)
            {
                if (lookAhead.getType() == TokenType.SUBJECT)
                {
                    main.addChild(0, subject());
                }
                else
                {
                    main.addChild(block());
                }
            }
            
            expect(TokenType.RBRACE);
            return file;
        }
        return error();
    }
    
    private static TokenTree subject()
    {
        TokenTree subject = new TokenTree(lookAhead);
        nextToken();
        expect(TokenType.LBRACE);
        
        subject.addChild(collapse(TokenType.RBRACE, "\\}"));
        
        expect(TokenType.RBRACE);
        return subject;
    }
    
    private static TokenTree block()
    {
        if (lookAhead.getType() == TokenType.MODIFIER
                || lookAhead.getType() == TokenType.TEST)
        {
            TokenTree modifier = new TokenTree(null);
            
            if (lookAhead.getType() == TokenType.MODIFIER)
            {
                modifier = new TokenTree(lookAhead);
                nextToken();
            }
            
            if (lookAhead.getType() == TokenType.TEST)
            {
                TokenTree test = new TokenTree(lookAhead);
                nextToken();
                test.addChild(modifier);
                
                if (lookAhead.getType() == TokenType.STRING)
                {
                    test.addChild(new TokenTree(lookAhead));
                    nextToken();
                }

                if (lookAhead.getType() == TokenType.LBRACE)
                {
                    expect(TokenType.LBRACE);
                    
                    TokenTree main = new TokenTree(null);
                    test.addChild(main);
                    
                    while (lookAhead.getType() != TokenType.RBRACE)
                    {
                        main.addChild(block());
                    }
                    
                    expect(TokenType.RBRACE);
                }
                else
                {
                    TokenTree main = new TokenTree(null);
                    test.addChild(main);
                    if (accept(TokenType.LBRACE))
                    {
                        main.addChild(statement());
                        accept(TokenType.RBRACE);
                    }
                    else
                    {
                        main.addChild(statement());
                    }
                }
                return test;
            }
            else
            {
                error();
            }
        }
        return statement();
    }
    
    private static TokenTree statement()
    {
        TokenTree method = method();
        
        if (lookAhead.getType() == TokenType.IS
                || lookAhead.getType() == TokenType.IS_NOT
                || lookAhead.getType() == TokenType.IS_EQ
                || lookAhead.getType() == TokenType.IS_NOT_EQ
                || lookAhead.getType() == TokenType.IS_LT
                || lookAhead.getType() == TokenType.IS_LTE
                || lookAhead.getType() == TokenType.IS_GT
                || lookAhead.getType() == TokenType.IS_GTE)
        {
            TokenTree statement = new TokenTree(lookAhead);
            nextToken();
            statement.addChild(method);
            
            if (accept(TokenType.BETWEEN))
            {
                TokenTree between = new TokenTree(null);
                statement.addChild(between);
                expect(TokenType.LPAREN);
                between.addChild(expression());
                expect(TokenType.COMMA);
                between.addChild(expression());
                int l = lookAhead.getLine();
                int c = lookAhead.getCol();
                expect(TokenType.RPAREN);
                
                if (accept(TokenType.DOT))
                {
                    if (lookAhead.getType() == TokenType.EXCL)
                    {
                        between.addChild(new TokenTree(lookAhead));
                        nextToken();
                    }
                    else
                    {
                        return error();
                    }
                }
                else
                {
                    between.addChild(new TokenTree(new Token(TokenType.EXCL, "inclusive", l, c)));
                }
            }
            else
            {
                statement.addChild(expression());
                
                if (getPrimitive(statement.getChild(1)) == 1
                        && lookAhead.getType() == TokenType.WITHIN)
                {
                    nextToken();
                    Token temp = lookAhead;
                    statement.addChild(expression());
                    
                    if (getPrimitive(statement.getChild(2)) != 1)
                    {
                        lookAhead = temp;
                        error();
                    }
                }
            }
            return statement;
        }
        else if (lookAhead.getType() == TokenType.MATCHES)
        {
            TokenTree statement = new TokenTree(lookAhead);
            nextToken();
            statement.addChild(method);
            
            if (lookAhead.getType() == TokenType.STRING)
            {
                statement.addChild(new TokenTree(lookAhead));
                nextToken();
            }
            else if (lookAhead.getType() == TokenType.REGEX)
            {
                statement.addChild(new TokenTree(new Token(TokenType.REGEX, lookAhead.getText().replaceAll("\\\\/", "/"), lookAhead.getLine(), lookAhead.getCol())));
                nextToken();
            }
            else
            {
                return error();
            }
            return statement;
        }
        else if (lookAhead.getType() == TokenType.INSTANCEOF
                || lookAhead.getType() == TokenType.THROWS)
        {
            TokenTree statement = new TokenTree(lookAhead);
            nextToken();
            statement.addChild(method);
            statement.addChild(expression());
            return statement;
        }
        else
        {
            TokenTree statement = new TokenTree(null);
            statement.addChild(method);
            return statement;
        }
    }
    
    private static TokenTree method()
    {
        if (lookAhead.getType() == TokenType.IDENTIFIER)
        {
            TokenTree method = new TokenTree(lookAhead);
            nextToken();
            expect(TokenType.LPAREN);
            
            method.addChild(collapse(TokenType.RPAREN, "\\)"));
            
            expect(TokenType.RPAREN);
            
            if (lookAhead.getType() == TokenType.IO)
            {
                TokenTree in = new TokenTree(null);
                method.addChild(in);
                TokenTree out = new TokenTree(null);
                method.addChild(out);
                
                while (lookAhead.getType() == TokenType.IO)
                {
                    if (lookAhead.getText().equals("<<"))
                    {
                        nextToken();
                        if (lookAhead.getType() == TokenType.STRING)
                        {
                            in.addChild(new TokenTree(new Token(TokenType.IDENTIFIER,
                                    lookAhead.getText().substring(1, lookAhead.getText().length() - 1),
                                    lookAhead.getLine(), lookAhead.getCol())));
                            nextToken();
                        }
                        else
                        {
                            in.addChild(concat("<<|>>|\n"));
                        }
                    }
                    else
                    {
                        nextToken();
                        if (lookAhead.getType() == TokenType.STRING)
                        {
                            out.addChild(new TokenTree(new Token(TokenType.IDENTIFIER,
                                    lookAhead.getText().substring(1, lookAhead.getText().length() - 1),
                                    lookAhead.getLine(), lookAhead.getCol())));
                            nextToken();
                        }
                        else
                        {
                            out.addChild(concat("<<|>>|\n"));
                        }
                    }
                }
            }
            
            if (accept(TokenType.DOT))
            {
                method.addChild(method());
            }
            
            return method;
        }
        return error();
    }
    
    private static TokenTree expression()
    {
        TokenTree term = term();
        TokenTree main = null;
        TokenTree root = null;
        while (lookAhead.getType() == TokenType.ADD)
        {
            TokenTree temp = new TokenTree(lookAhead);
            if (root != null)
            {
                root.addChild(temp);
            }
            else
            {
                main = temp;
            }
            root = temp;
            root.addChild(term);
            nextToken();
            term = term();
        }
        if (root == null)
        {
            return term;
        }
        root.addChild(term);
        return main;
    }
    
    private static TokenTree term()
    {
        TokenTree factor = factor();
        TokenTree main = null;
        TokenTree root = null;
        while (lookAhead.getType() == TokenType.MULT)
        {
            TokenTree temp = new TokenTree(lookAhead);
            if (root != null)
            {
                root.addChild(temp);
            }
            else
            {
                main = temp;
            }
            root = temp;
            root.addChild(factor);
            nextToken();
            factor = factor();
        }
        if (root == null)
        {
            return factor;
        }
        root.addChild(factor);
        return main;
    }
    
    private static TokenTree factor()
    {
        TokenTree atom = atom();
        TokenTree main = null;
        TokenTree root = null;
        while (lookAhead.getType() == TokenType.POW)
        {
            TokenTree temp = new TokenTree(lookAhead);
            if (root != null)
            {
                root.addChild(temp);
            }
            else
            {
                main = temp;
            }
            root = temp;
            root.addChild(atom);
            nextToken();
            atom = atom();
        }
        if (root == null)
        {
            return atom;
        }
        root.addChild(atom);
        return main;
    }
    
    private static TokenTree atom()
    {
        TokenTree t = new TokenTree(lookAhead);
        if (accept(TokenType.INTEGER)
                || accept(TokenType.FLOAT)
                || accept(TokenType.STRING)
                || accept(TokenType.IDENTIFIER))
        {
            return t;
        }
        else if (accept(TokenType.LPAREN))
        {
            t = expression();
            expect(TokenType.RPAREN);
            return t;
        }
        return error();
    }
    
    private static TokenTree collapse(TokenType delimiterType, String delimiterText)
    {
        int level = 0;
        
        ArrayList<Token> units = new ArrayList<Token>();
        
        while (lookAhead.getType() != delimiterType
                || !lookAhead.getText().matches(delimiterText)
                || level > 0)
        {
            if (lookAhead.getType() == TokenType.EOF)
            {
                error();
            }
            else if (lookAhead.getType() == TokenType.LBRACE
                    || lookAhead.getType() == TokenType.LPAREN)
            {
                level++;
            }
            else if (lookAhead.getType() == TokenType.RBRACE
                    || lookAhead.getType() == TokenType.RPAREN)
            {
                level--;
            }
            
            units.add(lookAhead);
            tokens.remove(0);
            lookAhead = tokens.get(0);
        }
        
        TokenTree concat = new TokenTree(null);
        
        if (units.size() > 0)
        {
            int line = units.get(0).getLine();
            int col = units.get(0).getCol();
            
            StringBuffer str = new StringBuffer();
            
            for (Token t : units)
            {
                str.append(t.getText());
            }
            
            concat = new TokenTree(new Token(TokenType.IDENTIFIER, str.toString().trim(), line, col));
        }
        return concat;
    }
    
    private static TokenTree concat(String delimiterText)
    {
        ArrayList<Token> units = new ArrayList<Token>();
        
        while (!lookAhead.getText().matches(delimiterText))
        {
            if (lookAhead.getType() == TokenType.EOF)
            {
                error();
            }
            
            units.add(lookAhead);
            tokens.remove(0);
            lookAhead = tokens.get(0);
        }
        
        if (lookAhead.getType() == TokenType.WHITESPACE)
        {
            nextToken();
        }
        
        TokenTree concat = new TokenTree(null);
        
        if (units.size() > 0)
        {
            int line = units.get(0).getLine();
            int col = units.get(0).getCol();
            
            StringBuffer str = new StringBuffer();
            
            for (Token t : units)
            {
                str.append(t.getText());
            }
            
            concat = new TokenTree(new Token(TokenType.IDENTIFIER, str.toString().trim(), line, col));
        }
        return concat;
    }
    
    private static int getPrimitive(TokenTree root)
    {
        int primitive = 0;
        
        if (root.getChildren() == 0)
        {
            if (root.getToken().getType() == TokenType.FLOAT)
            {
                primitive = 1;
            }
            else if (root.getToken().getType() == TokenType.STRING)
            {
                primitive = 2;
            }
            return primitive;
        }
        
        for (int i = 0; root.getChildren() > i; i++)
        {
            if (root.getChild(i).getToken().getType() == TokenType.FLOAT
                    && primitive < 2)
            {
                primitive = 1;
            }
            else if (root.getChild(i).getToken().getType() == TokenType.STRING)
            {
                primitive = 2;
            }
            else
            {
                int c = getPrimitive(root.getChild(i));
                primitive = primitive > c ? primitive : c;
            }
        }
        return primitive;
    }
}
